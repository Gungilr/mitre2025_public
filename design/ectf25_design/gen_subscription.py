"""
Author: Ben Janis
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""

import argparse
import json
import struct
import ectf25_design.encoder

from pathlib import Path

from secrets import token_bytes
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.asymmetric import utils
import cryptography.hazmat.primitives.serialization as ecc_serialization
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from cryptography.hazmat.primitives.asymmetric import ed25519


from loguru import logger

def gen_subscription(
    secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate the contents of a subscription.

    The output of this will be passed to the Decoder using ectf25.tv.subscribe

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """

    # Load the json of the secrets file
    secrets = json.loads(secrets)

    # load the private key for signing
    private_key = Ed25519PrivateKey.from_private_bytes(bytes.fromhex(secrets['private_key']))

    root_key = None
    root_keys = secrets['root_keys']
    for rk_object in root_keys:
        if rk_object['channel_num'] == channel:
            root_key = bytes.fromhex(rk_object['root_key'])
            break

    if root_key == None:
        raise Exception(f"Channel {channel} not included in the secrets.  Please run gen_secrets, making sure to include channel {channel}")

    sub_kdk = bytes.fromhex(secrets['subscription_kdk'])

    # Find the highest level intermediate key whose lowest covered frame equals
    # the current frame number and whose highest covered frame is less than or
    # equal to the frame end
    
    # the highest-numbered underived frame
    curr_frame = start
    # stores final keys for decoder in tuple format: (frame_start, level, key)
    keys = []

    while curr_frame <= end:
        # the current key under consideration
        key, level = root_key, 64
        # the range of frames the current key covers
        covered_start, covered_end = 0, 2**64 - 1

        while True:
            if level <= 0:
                break

            if covered_start == curr_frame and covered_end <= end:
                break

            child_level = level - 1
            child_start = (curr_frame >> child_level) << child_level # salt

            key, level = ectf25_design.encoder.hash(key, child_start), child_level
            covered_start, covered_end = child_start, child_start + (1 << level) - 1

        if level == 0 and ((covered_start != curr_frame) or (covered_end != curr_frame)):
            raise Exception(f'could not derive frame #{curr_frame}!')

        keys.append((covered_start, level, key))
        # print(f'adding key: frame_start={covered_start}, level={level}, key={key.hex()}')
        curr_frame = covered_end + 1

    keys_serialized = b''
    for frame_start, level, key in keys:
        # This aligns with key_entry_packet_t
        keys_serialized += struct.pack('<QB', frame_start, level) + key


    nonce = token_bytes(12)
    meta_data = struct.pack('<IBQQ', channel, len(keys), start, end) + nonce
    # encrypting the subscription using a key derived from the kdk
    subscription_key = HKDF(algorithm=hashes.SHA256(), length=32, salt=nonce, info=device_id.to_bytes(4, byteorder='little')).derive(sub_kdk)  # might need to swap byteorder depending on linux or max
    # print(f"Subscription key: {subscription_key.hex()}\nKDK: {sub_kdk.hex()}\nDecoder ID: {device_id.to_bytes(4, byteorder='big').hex()}\nNonce: {nonce.hex()}\n")
    cipher = ChaCha20Poly1305(subscription_key)
    encrypted_keys = cipher.encrypt(nonce, keys_serialized, meta_data)  # includes the tag at the end after the data

    packed_data = meta_data + encrypted_keys[-16:] + encrypted_keys[:-16]  # metadata + tag + encrypted keys
    
    # sign the subscription
    sig = private_key.sign(packed_data)

    """
             64 bytes          4 bytes    1 byte     8 bytes       8 bytes         12 bytes             16 bytes          # Keys x sizeof(key_entry_packet_t)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------
    |                       |           |        |             |             |                 |                       |                                       |
    |       Signature       |   Ch. #   | # Keys |    Start    |     End     |      Nonce      |          Tag          |             Encrypted Keys            |
    |                       |           |        |             |             |                 |                       |                                       |
    ------------------------------------------------------------------------------------------------------------------------------------------------------------
    """
    # Pack the subscription. This will be sent to the decoder with ectf25.tv.subscribe
    # This aligns with subscription_update_packet_t
    return sig + packed_data


def parse_args():
    """Define and parse the command line arguments

    NOTE: Your design must not change this function
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()


def main():
    """Main function of gen_subscription

    You will likely not have to change this function
    """
    # Parse the command line arguments
    args = parse_args()

    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )

    # Print the generated subscription for your own debugging
    # Attackers will NOT have access to the output of this (although they may have
    # subscriptions in certain scenarios), but feel free to remove
    #
    # NOTE: Printing sensitive data is generally not good security practice
    logger.debug(f"Generated subscription: {subscription}")

    # Open the file, erroring if the file exists unless the --force arg is provided
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)

    # For your own debugging. Feel free to remove
    logger.success(f"Wrote subscription to {str(args.subscription_file.absolute())}")


if __name__ == "__main__":
    main()
